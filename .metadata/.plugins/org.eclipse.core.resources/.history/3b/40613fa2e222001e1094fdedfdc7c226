#include "pidPlus.h"
#include "main.h"
/*
变积分算法
防止刚开始的时候由于误差较大导致的积分项过大——超调
*/
static float VariableIntegralCoefficient(float error, float absMax, float absMin)
{
    float factor = 0.0f;

    if (fabs(error) <= absMin)
    {
        factor = 1.0f;
    }
    else if (fabs(error) > absMax)
    {
        factor = 0.0f;
    }
    else
    {
        // 这里可以设置为一个常数类似于Ki的设置，选取量是需要比Kp小1-2个数量级的
        factor = (absMax - fabs(error)) / (absMax - absMin);
    }

    return factor;
}
// 初始化
void PID_init(PID* pid, TIM_HandleTypeDef* htim)
{
    pid->kp = 0;
    pid->ki = 0;
    pid->kd = 0;
    pid->target = 0;
    pid->maximum = 0.9;
    pid->minimum = 0.1;
    pid->deadBand = 0.01;
    pid->alpha = 0;
    pid->timCount = __HAL_TIM_GET_COUNTER(htim);
    pid->errorAbsMax = 5;       /*偏差绝对值最大值*/
    pid->errorAbsMin = 1;       /*偏差绝对值最小值*/
}

// 带死区、抗积分饱和、梯形积分、变积分算法以及不完全微分算法的增量型PID控
// 制器。
float PID_regulator(PID* pid, float messure)
{
    float thisError; 
    float factor; // 变积分系数  0-1.0
    float increment;
    float pError, dError, iError;

    thisError = pid->target - messure; // 得到偏差值
    if (fabs(thisError) > (pid->target * pid->deadBand))
    {
        pError = thisError - pid->lastError;
        iError = (thisError + pid->lastError) / 2.0f;
        dError = thisError - 2.0f * (pid->lastError) + pid->preError;
        // 变积分系数获取
        factor = VariableIntegralCoefficient(thisError, pid->errorAbsMax, pid->errorAbsMin);
        // 计算微分项增量带不完全微分
        pid->deltaDiff = pid->kd * (1.0f - pid->alpha) * dError + pid->alpha * pid->deltaDiff;
        // 增量计算
        increment = pid->kp * pError + pid->ki * factor * iError + pid->deltaDiff; 
    }
    else
    {
        if ((fabs(pid->target - pid->minimum) < pid->deadBand) && (fabs(messure - pid->minimum) < pid->deadBand))
        {
            pid->result = pid->minimum;
        }
        increment = 0.0f;
    }

    pid->result = pid->result + increment;

    if (pid->result >= pid->maximum)
    {
        pid->result = pid->maximum;
    }
    if (pid->result <= pid->minimum)
    {
        pid->result = pid->minimum;
    }

    pid->preError = pid->lastError; // 存放偏差用于下次运算
    pid->lastError = thisError;
//    pid->output = ((pid->result - pid->minimum) / (pid->maximum - pid->minimum)) * 1.0f;
//    /*对输出限值，避免超调和积分饱和问题*/
//    if (pid->output >= pid->maximum)
//    {
//        pid->output = pid->maximum;
//    }
//    if (pid->output <= pid->minimum)
//    {
//        pid->output = pid->minimum;
//    }
//    return pid->output;
}
